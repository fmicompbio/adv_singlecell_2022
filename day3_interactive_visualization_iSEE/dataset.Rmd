---
title: "Preprocessing a data set for iSEE"
author: "Charlotte Soneson, Kevin Rue-Albrecht, Federico Marini, and Aaron Lun"
date: "April 29, 2022"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_float: true
    toc_depth: 3
    fig_width: 5
    number_sections: false
    theme: united
bibliography: "iSEEWorkshop.bib"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  cache = FALSE,
  collapse = TRUE,
  comment = "#>",
  crop = NA
)
suppressPackageStartupMessages({
    require(BiocStyle)
})
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```


# Preparation of example scRNAseq data {#prepare-scrnaseq-data}

In this workshop, we use example data from the `r Biocpkg("TENxPBMCData")` package.
This package provides an _R / Bioconductor_ resource for representing and manipulating different single-cell RNA-seq data sets profiling peripheral blood mononuclear cells (PBMC) generated by 10x Genomics (https://support.10xgenomics.com/single-cell-gene-expression/datasets).

```{r, message=FALSE}
library(TENxPBMCData)
```

The man page for the `TENxPBMCData()` function gives an idea of the datasets that are available from this package.
It can be opened with the following command.

```{r, eval=FALSE}
help(TENxPBMCData)
```

Here, we use the `pbmc3k` dataset, which contains gene expression profiles for 2,700 single peripheral blood mononuclear cells.
The first time this dataset is loaded, this command downloads the dataset to a local cache, which takes some time, depending on the speed of your internet connection.
Subsequent times, the same command loads the dataset directly from the local cache.

```{r, message=FALSE, warning=FALSE}
sce <- TENxPBMCData(dataset = "pbmc3k")
```

At this point we can inspect the dataset in the console.

```{r}
sce
```

The dataset is provided as an object of the `SingleCellExperiment` class.
In particular, this summary view indicates that the following pieces of information are available:

- An assay matrix named `counts`
- Row (i.e., gene) names are Ensembl gene IDs
- Row metadata include for each gene the official gene symbol, and the gene symbol used by the
10x CellRanger quantification pipeline
- Column (i.e., cell) IDs are not initialized and left to `NULL`
- Column metadata include diverse information for each cell, including the cell barcode (`Barcode`) and the donor identifier (`Individual`).

Note that a `SingleCellExperiment` object (or, more generally, any `SummarizedExperiment` object) like this one already contains sufficient information to launch an interactive application instance to visualize the available data and metadata, using the `iSEE()` function.

For the purpose of this workshop, we first apply some preprocessing to the `SingleCellExperiment` object, in order to populate it with more information that can be visualized with `iSEE`.

We start by adding column names to the object, and use gene symbols instead of Ensembl IDs as row names.
In the case where multiple Ensembl identifiers correspond to the same gene symbol, the `scuttle::uniquifyFeatureNames` function concatenates the Ensembl ID and the gene symbol in order to generate unique feature names.

```{r, message=FALSE}
library(scuttle)
colnames(sce) <- paste0("Cell", seq_len(ncol(sce)))
rownames(sce) <- scuttle::uniquifyFeatureNames(
    ID = rowData(sce)$ENSEMBL_ID,
    names = rowData(sce)$Symbol_TENx
)
head(rownames(sce))
```

Next, we use the `r Biocpkg("scuttle")` package to calculate gene- and cell-level quality metrics.
These metrics are added as columns to the `rowData` and `colData` slots of the `SingleCellExperiment` object, respectively.
We also add some additional metrics that are not automatically computed by the `r Biocpkg("scuttle")` package.

```{r, message = FALSE}
MT <- rownames(sce)[grep("^MT-", rownames(sce))]
sce <- scuttle::addPerCellQC(sce, subsets = list(MT = MT))
sce <- scuttle::addPerFeatureQC(sce)
sce$log10_total <- log10(sce$total)
rowData(sce)$n_cells <- as.integer(rowData(sce)$detected / 100 * ncol(sce))
rowData(sce)$log10_total <- log10(rowSums(assay(sce, "counts")) + 1)
sce
```

We filter out a few cells with a large fraction of the counts coming from mitochondrial genes, since these may be damaged cells.
Notice the reduced number of columns in the dataset below.

```{r}
(sce <- sce[, sce$subsets_MT_percent < 5])
```

Next, we calculate size factors and normalized and log-transformed expression values, using the `r Biocpkg("scran")` and `r Biocpkg("scuttle")` packages.
Note that it is typically recommended to pre-cluster the cells before computing the size factors, as follows:

```{r}
# set.seed(1000)
# clusters <- scran::quickCluster(sce, BSPARAM = IrlbaParam())
# sce <- scran::computeSumFactors(sce, cluster = clusters, min.mean = 0.1)
```

However, for time reasons, we will skip the pre-clustering step in this workshop.

```{r, message=FALSE}
library(scran)
assay(sce, "counts") <- as(assay(sce, "counts"), "sparseMatrix")
sce <- scran::computeSumFactors(sce, min.mean = 0.1)
summary(sizeFactors(sce))
sce <- scuttle::logNormCounts(sce)
```

In order to extract the most informative genes, we first model the mean-variance trend and decompose the variance into biological and technical components.

```{r}
dec <- scran::modelGeneVar(sce)
top.dec <- dec[order(dec$bio, decreasing = TRUE), ] 
head(top.dec)
```

Next, we apply Principal Components Analysis (PCA), t-distributed Stochastic Neighbor Embedding (t-SNE) and Uniform Manifold Approximation and Projection (UMAP) to generate low-dimensional representations of the cells in our data set.
These low-dimensional representations are added to the `reducedDim` slot of the `SingleCellExperiment` object.

```{r, message=FALSE}
library(BiocSingular)
set.seed(1000)
sce <- scran::denoisePCA(sce, technical = dec, subset.row=NULL)
ncol(reducedDim(sce, "PCA"))
set.seed(1000)
sce <- scater::runTSNE(sce, dimred = "PCA", perplexity = 30)
sce <- scater::runUMAP(sce, dimred = "PCA")
sce
```

After this, we cluster the cells using a graph-based algorithm, and find 'marker genes' for each cluster as the genes that are significantly upregulated in the cluster compared to each of the other inferred clusters.
The adjusted p-values from this test, for each cluster, are added to the `rowData` slot of the object.

```{r}
snn.gr <- scran::buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_walktrap(snn.gr)
sce$Cluster <- factor(clusters$membership)
table(sce$Cluster)
markers <- scran::findMarkers(sce, groups = sce$Cluster,
                              test.type = "t",
                              direction = "up", pval.type = "all")
for (i in names(markers)) {
    rowData(sce)[, paste0("FDR_cluster", i)] <- 
        markers[[i]]$FDR[match(rownames(sce), 
                               rownames(markers[[i]]))]
}
sce
```

Finally, we assign a label to each cell, based on their individual transcriptome profiles, using the `r Biocpkg("SingleR")` package and the [Monaco immune data](https://doi.org/10.1016/j.celrep.2019.01.041) as a reference.
For each prediction, we store the labels in a specific `colData` column.

```{r message=FALSE}
library(SingleR)
library(celldex)
ref_monaco <- MonacoImmuneData()
```

Here we assign the cell type according to the main classification scheme 
(this includes `r knitr::combine_words(names(table(ref_monaco$label.main)))`).

```{r}
pred_monaco_main <- SingleR(test = sce, ref = ref_monaco, labels = ref_monaco$label.main)
table(pred_monaco_main$labels)
sce$labels_main <- pred_monaco_main$labels
```

We do something similar with a more fine-grained classification, this time including the cell subtypes (e.g., for `r sort(unique(ref_monaco$label.main))[1]`, the subtypes would include `r knitr::combine_words(names(table((ref_monaco$label.main), (ref_monaco$label.fine))[1, ])[which(table((ref_monaco$label.main), (ref_monaco$label.fine))[1,] > 0)])`).

```{r}
pred_monaco_fine <- SingleR(test = sce, ref = ref_monaco, labels = ref_monaco$label.fine)
table(pred_monaco_fine$labels)
sce$labels_fine <- pred_monaco_fine$labels
```

Similarly, we use the information contained in the cell ontology labels.

```{r}
pred_monaco_ont <- SingleR(test = sce, ref = ref_monaco, labels = ref_monaco$label.ont)
table(pred_monaco_ont$labels)
sce$labels_ont <- pred_monaco_ont$labels
```

The next table shows the relationship between the coarse and fine grained assignments in the data at hand.

```{r}
table(sce$labels_fine, sce$labels_main)
```

This concludes the preparation of the data.
We now have a `SingleCellExperiment` object that contains different types of abundance values, representations in reduced dimensions, as well as a range of row (feature) and column (cell) metadata.

# Overview plots

```{r}
scater::plotReducedDim(sce, dimred = "TSNE", colour_by = "labels_main")
scater::plotHighestExprs(sce, n = 20, colour_cells_by = "labels_main")
```

# Save data set

```{r}
saveRDS(sce, "pbmc3k.rds")
```

# Session info

```{r}
sessionInfo()
```


